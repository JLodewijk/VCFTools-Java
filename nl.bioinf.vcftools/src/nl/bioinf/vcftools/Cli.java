/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package nl.bioinf.vcftools;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.ParseException;

/**
 *
 * @author aponnudurai
 */
public class Cli {

    private Settings settings;

    public void parse(String[] args) {
        settings = new Settings();

        Options opt = defineOptions();
        CommandLineParser parser = new BasicParser();
        try {
            CommandLine cmd = parser.parse(opt, args);
            if (args.length > 0) {
                processOptions(cmd);
            } else {
                usages();
            }

        } catch (ParseException ex) {
            Logger.getLogger(Cli.class.getName()).log(Level.SEVERE, null, ex);
        }

    }

    public Settings getSettings() {
        return settings;
    }

    public void usages() {
        System.out.println("help function");
    }

    public Options defineOptions() {
        Options opt = new Options();
        opt.addOption("h", "help", false, "Help function");
//         opt.addOption("<oneLetterOption>","<multipleLetterOption>",true,"description"); // true = can accept arguments, false = can not accept arguments
        opt.addOption("vcf", true, "this option defines the VCF file to be processed");
        opt.addOption("gvcf", true, "this option defines the compressed VCF file to be processed");
        opt.addOption("bcf", true, "this option defines the BCF file to be processed");
        opt.addOption("out", true, "this option defines the output filename prefix for all files generated by vcftools");
        opt.addOption("chr", true, "chromosome identifiers can be used more than once to include or exclude multiple chromosomes. Seperate the identifiers with ',' if mulitiple identifiers are given");
        opt.addOption("fromBp", true, "this option defines the physical start position of site will be processed. A integer is expected");
        opt.addOption("toBp", true, "this option defines the physical stop position of site will be processed. A integer is expected");
        opt.addOption("snp", true, "this option defines a snp which will be processed. A string is excepted");
        opt.addOption("snpFile", true, "include a list of SNPs given in a file, with one ID per line");
        opt.addOption("excludeSnp", true, "exclude SNPs which are given by the user. Seperate the snps with a ',' if mulitple snp are given");
        opt.addOption("excludeSnpFile", true, "exclude a list of SNPs given in a file. The file should contain a list of SNP IDs, with one ID per line");
        opt.addOption("positions", true, "include a set of sites. Seperate with ',' if multiple sites are wanted to be given");
        opt.addOption("positionsFile", true, "include a set of sites on the basis of a list of positions in a file");

        opt.addOption("excludePositions", true, "exclude a set of sites on the basis of a list of positions in a file");
        opt.addOption("excludePositionsFile", true, "exclude a set of sites on the basis of a list of positions in a file");
        opt.addOption("keepOnlyIndels", true, "include or exclude sites that contain an indel");
        opt.addOption("removeIndels", true, "exclude or exclude sites that contain an indel");
        opt.addOption("keepOnlyIndels", true, "include or exclude sites that contain an indel");
        opt.addOption("bed", true, "include a set of sites on the basis of a BED files");
        opt.addOption("excludeBed", true, "exclude a set of sites on the basis of a BED files");
        opt.addOption("removeFilterdAll", false, "this option removes all sites with a FILTER flag");
        opt.addOption("removeFiltered", true, "exclude sites with a specific filter flag");
        opt.addOption("keepFiltered", true, "this option can be used to select sites on the basis of specific filter flags");
        opt.addOption("removeInfo", true, "this option can be used to exclude sites with a specific INFO flag");
        opt.addOption("keepInfo", true, "this option can be used to select sites on the basis of specific INFO flags, keepInfo is applied befor removeInfo if both are given");
        opt.addOption("minQ", true, "include only sites with Quality above this threshold. A float is expected");
        opt.addOption("minMeanDP", true, "include sites with mean Depth within the thresholds defined by the user. A float is expected");
        opt.addOption("maxMeandDP", true, "include sites with mean Depth within the thresholds defined by the user. A float is expected");
        opt.addOption("maf", true, "include only sites with Minor Allele Frequency within the specified range. A float is expected");
        opt.addOption("maxMaf", true, "include only sites with Minor Allele Frequency within a range which is specified by the user. A float is expected");
        opt.addOption("nonRefAf", true, "include only sites with all Non-Reference Allele Frequencies within the specified range. A float is expected");
        opt.addOption("maxNonRefAf", true, "include only sites with all Non-Reference Allele Frequencies within the specified range with a maximum specified by the user as a float");
        opt.addOption("mac", true, "include only sites with Minor Allele Count within the specified range. A float is expected");
        opt.addOption("maxMac", true, "include only sites with Minor Allele Count within the specified range with a maximum which is given by the user as a float");
        opt.addOption("nonRefAc", true, "include only sites with all Non-Reference Allele Counts within the specified range. A float is expected");
        opt.addOption("maxNonRefAc", true, "include only sites with all Non-Reference Allele Counts within the specified range with a maximum which is given by the user as a float");
        opt.addOption("hwe", true, "assesses sites for Hardy-Weinberg Equilibrium using an exact test sites with a p-value below the threshold defined by this option are taken to be out of HWE, and therefore excluded. A float is expected");
        opt.addOption("geno", true, "exclude sites on the basis of the proportion of missing data (defined to be between 0 and 1, where 1 indicates no missing data allowed). A float is expected");
        opt.addOption("maxMissingCount", true, "exclude sites which has more than this number of missing chromosomes. An integer is expected");
        opt.addOption("minAlleles", true, "include only sites with a number of alleles within the specified range. For example, to include only bi-allelic sites, one could use --minAlleles 2. A interger is expected");
        opt.addOption("maxAlleles", true, "include only sites with a number of alleles within the specified range. For example, to include only bi-allelic sites, one could use --maxAlleles 2. A interger is expected");
        opt.addOption("thin", true, "thin sites so that no two sites are within the specified distance. An integer is expected");
        opt.addOption("mask", true, "include sites on the basis of a FASTA-like file");
        opt.addOption("invertMask", true, "this option can be used to specify a mask file that will be inverted before being applied");
        opt.addOption("maskMin", true, "set the threshold value which determines if sites are filtered or not. An integer is expected");
        opt.addOption("indv", true, "specify an individual to be kept in the analysis. This option can be used multiple times to specify multiple individuals. A string is expected");
        opt.addOption("keep", true, "provide a file containing a list of individuals to include in subsequent analysis. Each individual ID (as defined in the VCF headerline) should be included on a separate line");
        opt.addOption("removeIndv", true, "specify an individual to be removed from the analysis. A string is expected. If --indv also used, --indv will be applied first.");
        opt.addOption("remove", true, "provide a file containing a list of individuals to exclude in subsequent analysis. Each individual ID (as defined in the VCF headerline) should be included on a separate line If --keep also used, --keep will be applied first");
        opt.addOption("minIndvMeanDP", true, "calculate the mean coverage on a per-individual basis. Only individuals with coverage of a minimal thresshold specified by these options are included in subsequent analyses. A float is expected");
        opt.addOption("maxIndvMeanDP", true, "calculate the mean coverage on a per-individual basis. Only individuals with coverage of a maximal thresshold specified by these options are included in subsequent analyses. A float is expected");
        opt.addOption("mind", true, "specify the minimum call rate threshold for each individual. A float is expected");
        opt.addOption("phased", true, "first excludes all individuals having all genotypes unphased, and subsequently excludes all sites with unphased genotypes. The remaining data therefore consists of phased data only");
        opt.addOption("maxIndv", true, "randomly thins individuals so that only the specified number are retained. An integer is expected");
        opt.addOption("count", false, "this option results a file with a raw count of allele per site of a given VCF file with the suffix .frq.count");
        opt.addOption("freq", false, "outputs the allele frequency in a file with the suffix .frq");
        opt.addOption("depth", false, "generates a file containing the mean depth per individual. This file has the suffix .idepth");

        return opt;
    }

    public void processOptions(CommandLine cmd) {

//         settings settings = new settings();
        if (cmd.hasOption("vcf")) {

            settings.setInputFile(cmd.getOptionValue("vcf"));
        }

//            Settings.getInstance().setInputFile(cmd.getOptionValue("vcf"));
//            System.out.println(Settings.getInstance().getInputFile());
//        if(cmd.hasOption("gvcf")){settings.setGzipped(true);}
//        if(cmd.hasOption("out")){settings.setOutputFile(true);}
//        if(cmd.hasOption("chr")){
//            String chrIdentifiers = cmd.getOptionValue("chr");
//            ArrayList<String> arrayListChr = new ArrayList<String>();
//            
//            String[] splitedchrIdentifiers = chrIdentifiers.split(",");
//            for(String identifier: splitedchrIdentifiers){
//            arrayListChr.add(identifier);
//            }
//         
////            System.out.println(Settings.getChr());
//        }
//        if(cmd.hasOption("notChr")){
//        String chrIdentifiers = cmd.getOptionValue("notChr");
//            ArrayList<String> arrayListNotChr = new ArrayList<String>();
//            
//            String[] splitedchrIdentifiers = chrIdentifiers.split(",");
//            for(String identifier: splitedchrIdentifiers){
//            arrayListNotChr.add(identifier);
////            settings.setNotChr(arrayListNotChr);
//            }
//            }
//    
//       if(cmd.hasOption("fromBp")){
////           settings.setFromBp(cmd.getOptionValue("fromBp"));
//       }
//       if(cmd.hasOption("toBp")){
////       settings.setToBp(cmd.getOptionValue("toBp"));
//       }
//       if(cmd.hasOption("snp")){
//       String snpIdentifiers = cmd.getOptionValue("snp");
//       ArrayList<String> arrayListSnp = new ArrayList<String>();
//           
//       String[] splitedSnpIdentifiers = snpIdentifiers.split(",");
//            for(String identifier: splitedSnpIdentifiers){
//            arrayListSnp.add(identifier);
//
//       }
////            settings.setSnp(arrayListNotChr);
//       }
//      if(cmd.hasOption("snpFile")){
////      settinings.setSnp(cmd.getOptionValue("snpFile"));
//        }
//      if(cmd.hasOption("excludeSnp")){
//      String excludeSnpIdentifiers = cmd.getOptionValue("excludeSnp");
//       ArrayList<String> arrayListExcludeSnp = new ArrayList<String>();
//       
//       String[] splitedExcludedIdentifiers = excludeSnpIdentifiers.split(",");
//      for(String identifiers: splitedExcludedIdentifiers ){
//      arrayListExcludeSnp.add(identifiers);}
//      
//      }
//      if(cmd.hasOption("excludeSnp")){
////      settings.setExcludeSnp(arrayListExcludedSnp);
//      }
//      if(cmd.hasOption("positions")){
//      String positions = cmd.getOptionValue("positions");
//      String [] splitedPositions = positions.split(",");
//      ArrayList<String> arrayListPosition = new ArrayList<String>();
//       
//      for(String pos: splitedPositions){
//      arrayListPosition.add(pos);
//      }
////      settings.setPositions(arrayListPosition)
//      }
//      if(cmd.hasOption("positionsFile")){
////      settings.setPositionsFile(cmd.getOptionValue("positionsFile"));
//      }
//      if(cmd.hasOption("excludePositions")){
//      String excludePositions = cmd.getOptionValue("excludePositions");
//      String[] splitedExcludePositions = excludePositions.split(",");
//      
//       ArrayList<String> arrayListExcludePositions = new ArrayList<String>();
//       for(String exPos : splitedExcludePositions){
//       arrayListExcludePositions.add(exPos);
//       }
////      settings.getInstance().setExcludePositions(arrayListExcludePositions);
//      }
    }

}
