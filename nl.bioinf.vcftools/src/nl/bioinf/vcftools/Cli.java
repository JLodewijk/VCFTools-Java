/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package nl.bioinf.vcftools;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.ParseException;
import nl.bioinf.vcftools.Settings;
import org.apache.commons.cli.HelpFormatter;

/**
 *
 * @author aponnudurai
 */
public class Cli {

    private Settings settings;
    private HelpFormatter helpFormatter;
    private Options option;
    private CommandLine cmd;
    private String[] args;

    /**
     * Constructor processing options and arguments.
     *
     * @param args arguments given on the commandline
     */
    Cli(String[] args) throws ParseException {

        this.args = args;
        this.option = defineOptions();
        this.helpFormatter = new HelpFormatter();
        this.settings = new Settings();

        try {
            CommandLineParser parser = new BasicParser();
            this.cmd = parser.parse(this.option, args);
        } catch (ParseException e) {
            System.err.println(e.getLocalizedMessage());
            System.exit(0);
        }

        checkOptions();

        procesOptions();

    }

    /**
     * Function to define options which can be given by the user
     *
     * @return opt
     */
    public Options defineOptions() {
        Options opt = new Options();
        opt.addOption("h", "help", false, "Help function");

//        Basic Settings 
        opt.addOption("vcf", true, "this option defines the VCF file to be processed");
        opt.addOption("gvcf", true, "this option defines the compressed VCF file to be processed");
        opt.addOption("bcf", true, "this option defines the BCF file to be processed");
        opt.addOption("out", true, "this option defines the output filename prefix for all files generated by vcftools");

//         Site Filters 
        opt.addOption("chr", true, "chromosome identifiers can be used more than once to include multiple chromosomes. Seperate the identifiers with ',' if mulitiple identifiers are given");
        opt.addOption("notChr", true, "chromosome identifiers can be used more than once to exlude multiple chromosomes. Seperate the identifiers with ',' if mulitiple identifiers are given");
        opt.addOption("fromBp", true, "this option defines the physical start position of site will be processed. A integer is expected. This option must be used in right after -chr");
        opt.addOption("toBp", true, "this option defines the physical stop position of site will be processed. A integer is expected. This option must be used in right after -toBp");
        opt.addOption("snp", true, "this option defines a snp which will be processed. A string is excepted");
        opt.addOption("snpFile", true, "include a list of SNPs given in a file, with one ID per line");
        opt.addOption("excludeSnp", true, "exclude SNPs which are given by the user. Seperate the snps with a ',' if mulitple snp are given");
        opt.addOption("excludeSnpFile", true, "exclude a list of SNPs given in a file. The file should contain a list of SNP IDs, with one ID per line");
        opt.addOption("positions", true, "include a set of sites. Seperate with ',' if multiple sites are wanted to be given");
        opt.addOption("positionsFile", true, "include a set of sites on the basis of a list of positions in a file");
        opt.addOption("excludePositions", true, "exclude a set of sites on the basis of a list of positions in a file");
        opt.addOption("excludePositionsFile", true, "exclude a set of sites on the basis of a list of positions in a file");
        opt.addOption("keepOnlyIndels", true, "include or exclude sites that contain an indel");
        opt.addOption("removeIndels", true, "exclude or exclude sites that contain an indel");
        opt.addOption("bed", true, "include a set of sites on the basis of a BED files");
        opt.addOption("exludeBed", true, "exclude a set of sites on the basis of a BED files");
        opt.addOption("removeFilteredAll", false, "this option removes all sites with a FILTER flag");
        opt.addOption("removeFiltered", true, "exclude sites with a specific filter flag");
        opt.addOption("keepFiltered", true, "this option can be used to select sites on the basis of specific filter flags"); //check required if arg = FLAG and no INFO field value
        opt.addOption("removeInfo", true, "this option can be used to exclude sites with a specific INFO flag");
        opt.addOption("keepInfo", true, "this option can be used to select sites on the basis of specific INFO flags, keepInfo is applied befor removeInfo if both are given");
        opt.addOption("minQ", true, "include only sites with Quality above this threshold. A Double is expected");
        opt.addOption("minMeanDP", true, "include sites with mean Depth within the thresholds defined by the user. A Double is expected");
        opt.addOption("maxMeanDP", true, "include sites with mean Depth within the thresholds defined by the user. A Double is expected");
        opt.addOption("maf", true, "include only sites with Minor Allele Frequency within the specified range. A Double is expected");
        opt.addOption("maxMaf", true, "include only sites with Minor Allele Frequency within a range which is specified by the user. A Double is expected");
        opt.addOption("nonRefAf", true, "include only sites with all Non-Reference Allele Frequencies within the specified range. A Double is expected");
        opt.addOption("maxNonRefAf", true, "include only sites with all Non-Reference Allele Frequencies within the specified range with a maximum specified by the user as a Double");
        opt.addOption("mac", true, "include only sites with Minor Allele Count within the specified range. A Double is expected");
        opt.addOption("maxMac", true, "include only sites with Minor Allele Count within the specified range with a maximum which is given by the user as a Double");
        opt.addOption("nonRefAc", true, "include only sites with all Non-Reference Allele Counts within the specified range. A Double is expected");
        opt.addOption("maxNonRefAc", true, "include only sites with all Non-Reference Allele Counts within the specified range with a maximum which is given by the user as a Double");
        opt.addOption("hwe", true, "assesses sites for Hardy-Weinberg Equilibrium using an exact test sites with a p-value below the threshold defined by this option are taken to be out of HWE, and therefore excluded. A Double is expected");
        opt.addOption("geno", true, "exclude sites on the basis of the proportion of missing data (defined to be between 0 and 1, where 1 indicates no missing data allowed). A Double is expected");
        opt.addOption("maxMissingCount", true, "exclude sites which has more than this number of missing chromosomes. An integer is expected");
        opt.addOption("minAlleles", true, "include only sites with a number of alleles within the specified range. For example, to include only bi-allelic sites, one could use --minAlleles 2. A interger is expected");
        opt.addOption("maxAlleles", true, "include only sites with a number of alleles within the specified range. For example, to include only bi-allelic sites, one could use --maxAlleles 2. A interger is expected");
        opt.addOption("thin", true, "thin sites so that no two sites are within the specified distance. An integer is expected");
        opt.addOption("mask", true, "include sites on the basis of a FASTA-like file");
        opt.addOption("invertMask", true, "this option can be used to specify a mask file that will be inverted before being applied");
        opt.addOption("maskMin", true, "set the threshold value which determines if sites are filtered or not. An integer is expected");

//        Individual filters 
        opt.addOption("keepIndv", true, "specify an individual to be kept in the analysis. This option can accept multiple arguments to specify multiple individuals. Each individual should be seperated with a ','. A string is expected");
        opt.addOption("keepIndvFile", true, "provide a file containing a list of individuals to include in subsequent analysis. Each individual ID (as defined in the VCF headerline) should be included on a separate line");
        opt.addOption("removeIndv", true, "specify an individual to be removed from the analysis. A string is expected. If --indv also used, --indv will be applied first.");
        opt.addOption("removeIndvFile", true, "provide a file containing a list of individuals to exclude in subsequent analysis. Each individual ID (as defined in the VCF headerline) should be included on a separate line If --keep also used, --keep will be applied first");
        opt.addOption("minIndvMeanDp", true, "calculate the mean coverage on a per-individual basis. Only individuals with coverage of a minimal thresshold specified by these options are included in subsequent analyses. A Double is expected");
        opt.addOption("maxIndvMeanDP", true, "calculate the mean coverage on a per-individual basis. Only individuals with coverage of a maximal thresshold specified by these options are included in subsequent analyses. A Double is expected");
        opt.addOption("mind", true, "specify the minimum call rate threshold for each individual. A Double is expected");
        opt.addOption("phased", true, "first excludes all individuals having all genotypes unphased, and subsequently excludes all sites with unphased genotypes. The remaining data therefore consists of phased data only");
        opt.addOption("maxIndv", true, "randomly thins individuals so that only the specified number are retained. An integer is expected");

//         Statistics 
        opt.addOption("count", false, "this option results a file with a raw count of allele per site of a given VCF file with the suffix .frq.count");
        opt.addOption("freq", false, "outputs the allele frequency in a file with the suffix .frq");
        opt.addOption("depth", false, "generates a file containing the mean depth per individual. This file has the suffix .idepth");

        return opt;
    }

    /**
     * Function to check if valid options are given
     */
    public void checkOptions() {
        System.out.println("checking options....");

        if (this.args.length < 1) {
            usage();
        }

        if (this.cmd.hasOption("fromBp") && !(this.cmd.hasOption("chr"))) {
            System.err.println("The options -fromBp and -toBp can only be used in conjunction with -chr");
            System.exit(0);
        }
        if (this.cmd.hasOption("fromBp") && !(this.cmd.hasOption("toBp") || this.cmd.hasOption("toBp") && !(this.cmd.hasOption("fromBp")))) {
            System.err.println("When the option -fromBp is given the -toBp is also required and vice-versa");
            usage();
        }
        if (this.cmd.hasOption("removeFilteredAll") && (this.cmd.hasOption("removeFiltered") || this.cmd.hasOption("keepFiltered"))) {
            System.err.println("When option -removeFilteredAll is given the options -removeFilterd or -keepFilterd are not allowed");
            System.exit(0);
        }
        if (cmd.hasOption("keepInfo") && cmd.hasOption("removeInfo")) {
            System.out.println("For the options: -keepInfo and -removeInfo"
                    + " the -keepInfo option will be executed first.");
        }
        if (cmd.hasOption("keepFiltered") && cmd.hasOption("removeFiltered")) {
            System.out.println("For the options: -keepFiltered and -removeFiltered"
                    + " the -keepFiltered option will be executed first.");
        }

        if (cmd.hasOption("minMeanDP") && !(cmd.hasOption("maxMeanDP")) || cmd.hasOption("maxMeanDP") && !(cmd.hasOption("minMeanDP"))) {
            System.err.println("It is obliged to use the options -minMeanDP and -maxMeanDP together");
            System.exit(0);
        }
        if (cmd.hasOption("maf") && !(cmd.hasOption("maxMaf")) || cmd.hasOption("maxMaf") && !(cmd.hasOption("maf"))) {
            System.err.println("It is obliged to use the options -maf and -maxMaf together");
        }
        if (cmd.hasOption("nonRefAf") && !(cmd.hasOption("maxNonRefAf")) || cmd.hasOption("maxNonRefAf") && !(cmd.hasOption("nonRefAf"))) {
            System.err.println("It is obliged to use the options -nonRefAf and -maxNonRefAf together");
            System.exit(0);
        }
        if (cmd.hasOption("mac") && !(cmd.hasOption("maxMac")) || cmd.hasOption("maxMac") && !(cmd.hasOption("mac"))) {
            System.err.println("It is obliged to use the options -mac and -maxMac together");
            System.exit(0);
        }
        if (cmd.hasOption("nonRefAc") && !(cmd.hasOption("maxNonRefAc")) || cmd.hasOption("maxNonRefAc") && !(cmd.hasOption("nonRefAc"))) {
            System.err.println("It is obliged to use the options -nonRefAc and -maxNonRefAc together");
            System.exit(0);
        }
        if (cmd.hasOption("geno")) {
            String geno = cmd.getOptionValue("geno");
            if (!(geno.equals("1")) || !(geno.equals("0"))) {
                System.err.println("The option -geno only allows 1 or 0. Where 1 indicates no missing data allowed");
                System.exit(0);
            }
        }
        if (cmd.hasOption("minAlleles") && !(cmd.hasOption("maxAlleles")) || cmd.hasOption("maxAlleles") && !(cmd.hasOption("minAlleles"))) {
            System.err.println("It is obliged to use the options -minAlleles and -maxAlleles together and vice-versa");
            System.exit(0);
        }

        if (this.cmd.hasOption("minIndvMeanDp") && !(this.cmd.hasOption("maxIndvMeanDP")) || this.cmd.hasOption("maxIndvMeanDP") && !(this.cmd.hasOption("minIndvMeanDp"))) {
            System.err.println("It is obliged to use the options -minIndvMeanDp and -maxIndvMeanDP together and vice-versa");
            System.exit(0);
        }

        if (cmd.hasOption("vcf")) {
            File file = new File(cmd.getOptionValue("vcf"));
            if (!(file.exists())) {
                System.err.println("file " + cmd.getOptionValue("vcf") + " can not be opend");
                System.exit(0);
            }
        }
        if (cmd.hasOption("excludeSnpFile")) {
            File file = new File(cmd.getOptionValue("excludeSnpFile"));
            if (!(file.exists())) {
                System.err.println("file " + cmd.getOptionValue("excludeSnpFile") + " can not be opend");
                System.exit(0);
            }
        }
        if (cmd.hasOption("positionsFile")) {
            File file = new File(cmd.getOptionValue("positionsFile"));
            if (!(file.exists())) {
                System.err.println("file " + cmd.getOptionValue("positionsFile") + " can not be opend");
                System.exit(0);
            }
        }
        if (cmd.hasOption("excludePositionsFile")) {
            File file = new File(cmd.getOptionValue("excludePositionsFile"));
            if (!(file.exists())) {
                System.err.println("file " + cmd.getOptionValue("excludePositionsFile") + " can not be opend");
                System.exit(0);
            }
        }
        if (cmd.hasOption("mask")) {
            File file = new File(cmd.getOptionValue("mask"));
            if (!(file.exists())) {
                System.err.println("file " + cmd.getOptionValue("mask") + " can not be opend");
                System.exit(0);
            }
        }
        if (cmd.hasOption("keepIndvFile")) {
            File file = new File(cmd.getOptionValue("keepIndvFile"));
            if (!(file.exists())) {
                System.err.println("file " + cmd.getOptionValue("keepIndvFile") + " can not be opend");
                System.exit(0);
            }
        }
        if (cmd.hasOption("removeIndvFile")) {
            File file = new File(cmd.getOptionValue("removeIndvFile"));
            if (!(file.exists())) {
                System.err.println("file " + cmd.getOptionValue("removeIndvFile") + " can not be opend");
                System.exit(0);
            }
        }
//        System.out.println("bleep");
//        System.out.println(cmd.getArgList());

    }

    /**
     * Set settings object
     *
     * @param settings
     */
    public void setSettings(Settings settings) {
        this.settings = settings;
    }

    /**
     * Get settings object
     *
     * @return settings
     */
    public Settings getSettings() {
        return settings;
    }

    /**
     * Usage, for when errors occur in program
     *
     */
    public void usage() {
        helpFormatter.printHelp("For analysing the VCF file several options can be used."
                + "This tool supports version higher than 4.0 . This tool is also"
                + "compatible for snp analysis in poliploid cells", this.option);
        System.exit(0);
    }

    /**
     * Function to set the Settings
     */
    public void procesOptions() {

//         Settings settings = new Settings();
        if (this.cmd.hasOption("h")) {
//        this.usages();
        }
        if (this.cmd.hasOption("vcf")) {

            settings.setInputFile(this.cmd.getOptionValue("vcf"));
        }

        settings.setInputFile(this.cmd.getOptionValue("vcf"));

        if (this.cmd.hasOption("gvcf")) {
            settings.setGzipped(true);
        }
        if (this.cmd.hasOption("out")) {
//            settings.setOutputFile(cmd.getOptionValue("out"));
        }
        if (this.cmd.hasOption("chr")) {

            for (int pointer = 0; pointer < this.args.length;pointer++) {
                if (this.args[pointer].equals("-chr")) {
                   
                    int fromValuePointer = pointer + 2;
                    int toValueFactor = pointer + 4;
                    
                    if (pointer + 2 == this.args.length) {
                        
                        settings.addChr(this.args[pointer+1]);
                        break;
                    }
                    if (this.args[fromValuePointer].equals("-fromBp") && this.args[toValueFactor].equals("-toBp")) {
                        int fromBp = Integer.parseInt(this.args[fromValuePointer + 1]);
                        int toBp = Integer.parseInt(this.args[toValueFactor + 1]);
                        settings.addChr(this.args[pointer+1], fromBp, toBp);
                    }

//                    } else {
//                       
//                        settings.addChr(this.args[pointer + 1]);
//                    }
                }

            }
        }
        if (this.cmd.hasOption("notChr")) {
            for (int pointer = 0; pointer < this.args.length; pointer++) {
                if (this.args[pointer].equals("-notChr")) {
//                    System.out.println(args[c]);
                    int fromValuePointer = pointer + 2;
                    int toValueFactor = pointer + 4;

                    if (pointer + 2 == this.args.length) {
                        break;
                    }
                    if (this.args[fromValuePointer].equals("-from") && this.args[toValueFactor].equals("-to")) {
                        int fromBp = Integer.parseInt(this.args[fromValuePointer + 1]);
                        int toBp = Integer.parseInt(this.args[toValueFactor + 1]);
                        settings.addNotChr(this.args[pointer + 1], fromBp, toBp);

                    } else {
                        settings.addNotChr(this.args[pointer + 1]);
                    }
                }

            }
        }

        if (this.cmd.hasOption("snp")) {
            String snpIdentifiers = this.cmd.getOptionValue("snp");

            String[] splitedSnpIdentifiers = snpIdentifiers.split(",");
            for (String identifier : splitedSnpIdentifiers) {
                settings.addSnp(identifier);

            }

        }
        if (this.cmd.hasOption("snpFile")) {
            settings.setSnpFile(this.cmd.getOptionValue("snpFile"));
        }
        if (this.cmd.hasOption("excludeSnp")) {
            String excludeSnpIdentifiers = this.cmd.getOptionValue("excludeSnp");

            String[] splitedExcludedIdentifiers = excludeSnpIdentifiers.split(",");
            for (String identifiers : splitedExcludedIdentifiers) {
                settings.addExcludeSnp(identifiers);
            }

        }
        if (this.cmd.hasOption("excludeSnpFile")) {
            settings.setExcludeSnpFile(this.cmd.getOptionValue("excludeSnpFile"));
        }

        if (this.cmd.hasOption("positionsFile")) {
            settings.setPositionsFile(this.cmd.getOptionValue("positionsFile"));
        }

        if (this.cmd.hasOption("excludePositionsFile")) {
            settings.setExcludePositionsFile(this.cmd.getOptionValue("excludePositionsFile"));
        }
        if (this.cmd.hasOption("keepOnlyIndels")) {
            settings.setKeepIndels(true);
        }
        if (this.cmd.hasOption("removeIndels")) {
            settings.setKeepIndels(false);
        }
        if (this.cmd.hasOption("bed")) {
//      Bed bed = new Bed();
            settings.setBedFile(this.cmd.getOptionValue("bed"));
        }
        if (this.cmd.hasOption("exludeBed")) {
//      Bed bed = new Bed()
//        settings.setExludeBed(this.cmd.getOptionValue("exludeBed"));
        }
        if (this.cmd.hasOption("removeFilteredAll")) {
            settings.setRemoveFilteredAll(true);
        }
        if (this.cmd.hasOption("removeFiltered")) {
            String removedFiltered = this.cmd.getOptionValue("removeFiltered");
            String[] splitedRemovedFiltered = removedFiltered.split(",");

            for (String removedItem : splitedRemovedFiltered) {
                settings.addRemoveFiltered(removedItem);
            }
            settings.setRemoveFiltered(settings.getRemoveFiltered());
        }
        if (this.cmd.hasOption("keepFiltered")) {
            String keepFiltered = this.cmd.getOptionValue("keepFiltered");
            String[] splitedKeepFiltered = keepFiltered.split(",");

            for (String keepFilteredItem : splitedKeepFiltered) {
                settings.addKeepFiltered(keepFilteredItem);
            }
            settings.setKeepFiltered(settings.getKeepFiltered());
        }
        if (this.cmd.hasOption("removeInfo")) {
            String removeInfo = this.cmd.getOptionValue("removeInfo");
            String[] splitedRemovedInfo = removeInfo.split(",");

            for (String removedInfoItem : splitedRemovedInfo) {
                settings.addRemoveInfo(removedInfoItem);
            }

        }
        if (this.cmd.hasOption("keepInfo")) {
            String keepInfo = this.cmd.getOptionValue("keepInfo");
            String[] splitedKeptInfo = keepInfo.split(",");

            for (String keptInfoItem : splitedKeptInfo) {
                settings.addKeepInfo(keepInfo);

            }
            settings.setKeepInfo(settings.getKeepInfo());
        }
        if (this.cmd.hasOption("minQ")) {
            Double minQValue = Double.parseDouble(this.cmd.getOptionValue("minQ"));
            settings.setMinQ(minQValue);
        }

        if (this.cmd.hasOption("minMeanDP")) {
            Double minMeanDP = Double.parseDouble(this.cmd.getOptionValue("minMeanDP"));
            settings.setMinMeanDp(minMeanDP);
        }
        if (this.cmd.hasOption("maxMeanDP")) {
            Double maxMeanDP = Double.parseDouble(this.cmd.getOptionValue("maxMeanDP"));
            settings.setMaxMeanDp(maxMeanDP);

        }
        if (this.cmd.hasOption("maf")) {
            Double maf = Double.parseDouble(this.cmd.getOptionValue("maf"));
            settings.setMaf(maf);
        }
        if (this.cmd.hasOption("maxMaf")) {
            Double maxMaf = Double.parseDouble(this.cmd.getOptionValue("maxMaf"));
            settings.setMaxMaf(maxMaf);
        }
        if (this.cmd.hasOption("nonRefAf")) {
            Double nonRefAf = Double.parseDouble(this.cmd.getOptionValue("nonRefAf"));
            settings.setNonRefAf(nonRefAf);
        }
        if (this.cmd.hasOption("maxNonRefAf")) {
            Double maxNonRefAf = Double.parseDouble(this.cmd.getOptionValue("maxNonRefAf"));
            settings.setMaxNonRefAf(maxNonRefAf);
        }
        if (this.cmd.hasOption("mac")) {
            int mac = Integer.parseInt(this.cmd.getOptionValue("mac"));
            settings.setMac(mac);
        }
        if (this.cmd.hasOption("maxMac")) {
            int maxMac = Integer.parseInt(this.cmd.getOptionValue("maxMac"));
            settings.setMaxMac(maxMac);
        }
        if (this.cmd.hasOption("nonRefAc")) {
            Double nonRefAc = Double.parseDouble(this.cmd.getOptionValue("nonRefAc"));
            settings.setNonRefAc(nonRefAc);
        }
        if (this.cmd.hasOption("maxNonRefAc")) {
            Double maxNonRefAc = Double.parseDouble(this.cmd.getOptionValue("maxNonRefAc"));
            settings.setMaxNonRefAc(maxNonRefAc);
        }
        if (this.cmd.hasOption("hwe")) {
            Double hwe = Double.parseDouble(this.cmd.getOptionValue("hwe"));
            settings.setHwe(hwe);
        }
        if (this.cmd.hasOption("geno")) {
            Double geno = Double.parseDouble(this.cmd.getOptionValue("geno"));
            settings.setGeno(geno);
        }
        if (this.cmd.hasOption("maxMissingCount")) {
            int maxMissingCount = Integer.parseInt(this.cmd.getOptionValue("maxMissingCount"));
//      settings.setMaxMissingCount(maxMissingCount);
        }
        if (this.cmd.hasOption("minAlleles")) {
            int minAlleles = Integer.parseInt(this.cmd.getOptionValue("minAlleles"));
            settings.setMinAlleles(minAlleles);
        }
        if (this.cmd.hasOption("maxAlleles")) {
            int maxAlleles = Integer.parseInt(this.cmd.getOptionValue("maxAlleles"));
            settings.setMaxAlleles(maxAlleles);
        }
        if (this.cmd.hasOption("thin")) {
            int thin = Integer.parseInt(this.cmd.getOptionValue("thin"));
            settings.setThin(thin);
        }
        if (this.cmd.hasOption("mask")) {
            settings.setMaskFile(this.cmd.getOptionValue("mask"));
        }
        if (this.cmd.hasOption("invertMask")) {
            settings.setInvertMaskFile(this.cmd.getOptionValue("invertMask"));
        }
        if (this.cmd.hasOption("maskMin")) {
            int maskMin = Integer.parseInt(this.cmd.getOptionValue("maskMin"));
            settings.setMaskMin(maskMin);
        }
        if (this.cmd.hasOption("keepIndv")) {
            String keepIndv = this.cmd.getOptionValue("keepIndv");
            String[] splitedKeptIndv = this.cmd.getOptionValues("keepIndv");

            for (String keepIndvItem : splitedKeptIndv) {
                settings.addKeepIndv(keepIndvItem);

            }

        }
        if (this.cmd.hasOption("keepIndvFile")) {
            settings.setKeepIndvFile(this.cmd.getOptionValue("keepIndvFile"));
        }
        if (this.cmd.hasOption("removeIndv")) {
            String removeIndv = this.cmd.getOptionValue("removeIndv");
            String[] splitedRemovedIndv = removeIndv.split(",");

            for (String removedIndvItem : splitedRemovedIndv) {
                settings.addRemoveIndv(removedIndvItem);
            }

        }
        if (this.cmd.hasOption("removeIndvFile")) {
            settings.setRemoveIndvFile(this.cmd.getOptionValue("removeIndvFile"));
        }
        if (this.cmd.hasOption("minIndvMeanDp")) {
            Double minIndvMeanDp = Double.parseDouble(this.cmd.getOptionValue("minIndvMeanDp"));
            settings.setMinIndvMeanDp(minIndvMeanDp);
        }
        if (this.cmd.hasOption("maxIndvMeanDp")) {
            Double maxIndvMeanDp = Double.parseDouble(this.cmd.getOptionValue("maxIndvMeanDp"));
            settings.setMaxIndvMeanDp(maxIndvMeanDp);
        }
        if (this.cmd.hasOption("mind")) {
            Double mind = Double.parseDouble(this.cmd.getOptionValue("mind"));
            settings.setMind(mind);
        }
        if (this.cmd.hasOption("phased")) {
            settings.setPhased(true);
        }
        if (this.cmd.hasOption("maxIndv")) {
            int maxIndv = Integer.parseInt(this.cmd.getOptionValue("maxIndv"));
            settings.setMaxIndv(maxIndv);
        }
        if (this.cmd.hasOption("count")) {
            settings.setCount(true);
        }
        if (this.cmd.hasOption("freq")) {
            settings.setFreq(true);
        }
        if (this.cmd.hasOption("depth")) {
            settings.setDepth(true);
        }

    }

}
